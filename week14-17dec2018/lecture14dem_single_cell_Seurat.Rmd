---
title: "Demo: Single-cell RNA-seq pipeline using Seurat"
author: "based originally on Seurat Guided Clustering Tutorial v2, modified by Lukas Weber + Stefan Milosavljevic (and updated to v3 and drastically reduced by Mark Robinson)"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    theme: united
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(cache = TRUE)
```


***

# Introduction {-}

This document demonstrates an analysis pipeline for single-cell RNA-sequencing (scRNA-seq) data. We use the `Seurat` R package, together with the 10X Genomics 2700 peripheral blood mononuclear cells (PBMCs) dataset.

The examples in this document are modified from the `Seurat` example vignette titled 'Guided Clustering Tutorial', available at https://satijalab.org/seurat/pbmc3k_tutorial_v3.html.

It is therefore important to install *v3* of the `Seurat` package; more details can be found at https://satijalab.org/seurat/install.html (Click on the _Version 3.0 Prerelease_ tab.)

# Download data and create 'Seurat' object {-}

```{r init, message=FALSE}
library(Seurat)
library(dplyr)
library(ggplot2)
library(pheatmap)

f <- "https://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz"
download.file(f, basename(f))

# Unzip data
dir.create("data")
(untar(basename(f), exdir = "data"))

# Load data
d <- Read10X("data/filtered_gene_bc_matrices/hg19/")
```

```{r create.object}
# Initialize the Seurat object
so <- CreateSeuratObject(counts = d, min.cells = 3, 
                         min.features = 200, project = "STA426_10X_PBMC")
so
```

# Pre-processing

Pre-processing steps for scRNA-seq data include:

- Filtering cells and genes based on quality control (QC) metrics
- Data normalization and scaling
- Selection of highly variable genes (used for downstream analysis, such as clustering)
- Removing unwanted sources of variation (if necessary)


## Quality control (QC) and filtering

Filtering can be used to exclude cells or genes that do not meet QC metrics. Here, we exclude cells with a clear outlier number of genes detected; these are assumed to be doublets or multiplets (two or more cells sequenced as a single cell). We also filter cells based on the percentage of mitochondrial genes present; high percentages of mitochondrial genes indicate damaged cells due to loss of cytoplasm.

```{r qc}
(mito.genes <- grep("^MT-", rownames(so), value = TRUE))
cnts <- so@assays$RNA
class(cnts)
prop.mito <- Matrix::colSums(cnts[mito.genes, ]) / Matrix::colSums(cnts)

# 'AddMetaData' adds columns to 'object@meta.data'
so <- AddMetaData(so, metadata = prop.mito, col.name = "prop.mito")
```

```{r, fig.height=4, fig.width=5}
# # Violin plots
VlnPlot(so, features = c("nCount_RNA", "nFeature_RNA", 
                         "prop.mito"), ncol = 3)

FeatureScatter(so, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + 
  scale_x_sqrt() + scale_y_sqrt() + geom_density_2d(colour="white") + 
  geom_hline(yintercept = c(400,1500)) +
  geom_vline(xintercept = c(1250, 4500))
```

```{r}
# We filter out cells that have unique gene counts over X or less than Y.
# Note that 'low.thresholds' and 'high.thresholds' are used to define a 'gate'.
dim(so)

so <- subset(so, nFeature_RNA > 400 & nFeature_RNA < 1500 &
               nCount_RNA > 1250 & nCount_RNA < 4500 & prop.mito < 0.05)

keep <- Matrix::rowSums(GetAssayData(so, "counts") > 0) >= 20
so <- so[keep,]

dim(so)

```


## Normalization and scaling

We use the normalization method `LogNormalize`, which normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result.

```{r normalize}
# Normalization
so <- NormalizeData(so, normalization.method = "LogNormalize",
                    scale.factor = 1e4)
```


## Selection of highly variable genes

`Seurat` detects highly variable genes and focuses on these for the downstream analysis.

`FindVariableGenes` calculates average expression and dispersion for each gene, places these genes into bins, and calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression (in general, higher average expression is associated with higher variability). The parameters here identify around 2,000 highly variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 10,000 molecules.

```{r var_genes, fig.height=4, fig.width=5}
# Find highly variable genes
so <- FindVariableFeatures(so, nfeatures = 1000)

VariableFeaturePlot(so) + geom_density_2d(colour="green")
```

```{r len_var_genes}
# Number of highly variable genes
length(VariableFeatures(so))
```


## Removing unwanted sources of variation

Your single cell dataset likely contains "uninteresting" sources of variation. This may include technical noise, batch effects, or biological sources of variation (e.g. cell cycle stage). Adjusting for (or "regressing out") these signals can improve downstream dimensionality reduction and clustering. `Seurat` does this by constructing linear models with "noisy" variables to predict gene expression, and storing the scaled z-scored residuals of these models in the `scale.data` slot; the residuals are then used for dimensionality reduction and clustering.

Here, we regress on the number of detected molecules per cell and the percentage mitochondrial gene content.

```{r regress, results='hide'}
# Regress out variables
so <- ScaleData(so, vars.to.regress = c("nCount_RNA", "prop.mito"))
```

***

# Dimensionality reduction and visualization

## Principal Component Analysis (PCA)

Next, we perform principal component analysis (PCA) (linear dimensionality reduction) on the pre-processed data.

By default, the highly variable genes stored in `object@var.genes` are used as input. This can also be customized with `pc.genes`.

```{r pca}
# PCA
so <- RunPCA(so, verbose = TRUE)
ElbowPlot(so)

# so <- RunUMAP(so, dims = 1:10)
so <- RunTSNE(so, dims = 1:10)
```


***

## Clustering

`Seurat` includes a graph-based clustering method, which seems to perform well given a recent comparison (https://f1000research.com/articles/7-1141/v2).

`FindClusters` runs the clustering, and contains a "resolution" parameter that sets the "granularity" of the clustering. Increased values give a greater number of clusters, which can be useful for detecting smaller or rare populations. The `Seurat` authors recommend setting this parameter between 0.6 -- 1.2 for single cell datasets of around 3000 cells; and optimal resolution is often higher for larger datasets.


```{r cluster}
# Run clustering
# 'save.SNN = TRUE' saves the shared nearest neighbor (SNN) graph, which lets you re-run
# the clustering with a different resolution value without needing to re-calculate the graph
so <- FindNeighbors(so)
so <- FindClusters(so)
```


***

# Differential analyses

## Differentially expressed genes between clusters (marker genes)

`Seurat` can help find 'marker genes' that define clusters via differential expression. These genes can be seen as "representative" genes for each cluster or cell population.

By default, `Seurat` identifes positive and negative markers for a single cluster (function `FindMarkers`, using argument `ident.1` to specify the cluster), compared to all other cells.

The `FindAllMarkers` function automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.


```{r}
# Find markers for every cluster compared to all remaining cells; report only the positive ones
pbmc.markers <- FindAllMarkers(so, only.pos = TRUE, 
                               min.pct = 0.25, thresh.use = 0.25)

pbmc.markers %>% filter(pct.1-pct.2 > .4) %>% 
  group_by(cluster) %>% 
  top_n(5, -p_val)
```


`Seurat` includes several visualization tools. `VlnPlot` (expression probability distributions across clusters) and `FeaturePlot` (gene expression on a tSNE or PCA plot) are commonly used visualizations. Other options include `RidgePlot`, and `DotPlot`.


```{r markerplots tSNE, fig.height=6, fig.width=6}
# tSNE plots
FeaturePlot(so, features = c("CD3D", "S100A8", "S100A9", "CD79A"))

RidgePlot(so, features = c("CD3D", "S100A8", "S100A9", "CD79A"))

VlnPlot(so, features = c("CD3D", "S100A8", "S100A9", "CD79A"))
```

### Generate heatmap

```{r clusterHeatmap, fig.height=5, fig.width=9, message=FALSE, warning=FALSE}
# Calculate top marker genes for each cluster
pbmc.markers %>% filter(pct.1-pct.2 > .3) %>% 
  group_by(cluster) %>% top_n(5, -p_val) -> top5


# This threw an error for me
# DoHeatmap(so, features = top5$gene)

fd <- FetchData(so, vars=top5$gene)

clust <- so@meta.data[,"RNA_snn_res.0.8"]

o <- order(clust)

acol = data.frame(cluster=clust, row.names = rownames(so@meta.data))

pheatmap(t(fd[o,]), cluster_cols = FALSE, 
         cluster_rows = FALSE, 
         show_colnames = FALSE, 
         annotation_col = acol[o,,drop=FALSE])
```


```{r sessioninfo}
sessionInfo()
```

<!-- Cluster ID | Markers       | Cell Type -->
<!-- -----------|---------------|---------- -->
<!-- 0          | IL7R          | CD4 T cells -->
<!-- 1          | CD14, LYZ     | CD14+ Monocytes -->
<!-- 2          | MS4A1         | B cells -->
<!-- 3          | CD8A          | CD8 T cells -->
<!-- 4          | FCGR3A, MS4A7 | FCGR3A+ Monocytes -->
<!-- 5          | GNLY, NKG7    | NK cells -->
<!-- 6          | FCER1A, CST3  | Dendritic Cells -->
<!-- 7          | PPBP          | Megakaryocytes -->

